---
format: closeread-html
---

# THE GEOGRAPHY OF HEALTHCARE

## MOBILE WOMEN’S HEALTH CLINICS IN TEXAS

### Section 1: Highlighting Need

Across the 268,597 square miles of Texas, access to women’s healthcare is deeply uneven. Large regions of the state function as “healthcare deserts,” where high- population communities have few or sometimes no access to nearby clinics providing essential services like contraception, cancer screenings, and preventive care. Many rural Texans face long travel distances, limited transportation options, and months-long wait times.

::::: {.cr-section layout="overlay-left"}
::: progress-block
These barriers make timely, comprehensive healthcare out of reach for many, underscoring the urgent need for solutions that meet people where they are. @cr-myimage

That’s where mobile health care units come in.

**Use the bar on the right to scroll through this story**
:::

::: {#cr-myimage}
```{=html}


<style>
.hero-video { width: 100%; height: 100vh; overflow: hidden; }
.hero-video video { width: 100vw; height: 100%; object-fit: cover; display: block; }
</style>

<div class="hero-video">
  <video autoplay muted loop playsinline preload="auto">
    <source src="output_video.mp4" type="video/mp4">
  </video>
</div>

```
:::
:::::

### Section 2: Health Outcomes.

::: {.cr-section .quote-section layout="overlay-left"}
Learn more. @cr-mytext1

| {#cr-mytext1 .cr-text .scale-to-fill}
| The impact on women’s health has been
| especially severe. Nearly half of
| Texas counties (46.5%) are classified as
| [maternity care deserts]{#cr-t1},
| meaning they lack access to
| birthing facilities
| or maternity care providers altogether.
| For thousands of women, even basic
| pregnancy care requires
| traveling far from home,
| [4.6% of Texas women]{#cr-t2} live
| more than 30 minutes from
| the nearest birthing hospital.

[@cr-mytext1]{hlz="cr-t1,cr-t2"} This is quite important here!
:::::

### Section 3: Mapping Need.

:::: {.cr-section layout="sidebar-left"}
**Population**\
The following map shows the population of women of reproductive age (15-49) in 2023. @cr-map

**Providers per 1,000**\
Here are all providers per 1,000 women of reproductive age (15-49) in 2023. @cr-map

FPP Providers. @cr-map

HTW Providers. @cr-map

::: {#cr-map}
```{r}
#| message: false
#| warning: false
library(leaflet)
library(leaflet.extras)
library(sf)
library(rmapshaper)
library(htmlwidgets)

center_lng <- -95.3; center_lat <- 31.0

texas_map <- st_read("GHWMI_PCWT_2023.geojson", quiet=TRUE) |> 
  st_transform(4326) |>
  ms_simplify(keep = 0.05, keep_shapes = TRUE)

providers <- st_read("ProviderLocations.geojson", quiet=TRUE) |>
  st_transform(4326)
providers <- providers[!is.na(providers$Latitude), ]

texas_map$population <- as.numeric(texas_map$PWCT_TX_2023_pop)
min_val <- min(texas_map$population, na.rm = TRUE)
texas_map$population[is.na(texas_map$population)] <- min_val

pal_pop <- colorNumeric(palette = c("#E6D9E4", "#53284F"), domain = texas_map$population)
pal_perk <- colorNumeric(palette = c("#E6D9E4", "#53284F"), domain = texas_map$PWCT_TX_2023_total_PerK)

m <- leaflet(
  elementId = "test_map",
  height = "85vh",
  width  = "68vw",
  options = leafletOptions(zoomDelta = 0.5, zoomSnap = 0, dragging = FALSE, minZoom = 6.3999)
) |>
  addProviderTiles("CartoDB.Positron", options = providerTileOptions(opacity = 0)) |>
  setView(lng = center_lng-3, lat = center_lat, zoom = 6.4999) |>   
  setMaxBounds(lng1 = -106.6, lat1 = 25.8, lng2 = -93.5, lat2 = 36.5) |>


  # --- BASE LAYERS (radio) ---
  addPolygons(
    data = texas_map,
    group = "Population",                 # baseGroups label
    fillColor = ~pal_pop(population),
    weight = 2, color = "white",
    fillOpacity = 1, stroke = TRUE,
    highlightOptions = highlightOptions(weight = 5, opacity = 1, color = "#D24699", bringToFront = TRUE),
    label = ~paste("There are", round(population, 0), "women aged 15–49 in this county."),
    popup = paste(texas_map$CNTY_NM, "County"),
    labelOptions = labelOptions(textsize = "15px", style = list("font-weight"="bold","padding"="6px"))
  ) |>
  addPolygons(
    data = texas_map,
    group = "Total Providers per 1,000 Women 15-49",   # baseGroups label
    fillColor = ~pal_perk(PWCT_TX_2023_total_PerK),
    weight = 2, color = "white",
    fillOpacity = 1, stroke = TRUE,
    highlightOptions = highlightOptions(weight = 5, opacity = 1, color = "#D24699", bringToFront = TRUE),
    label = ~paste("There are", round(PWCT_TX_2023_total_PerK, 2), "providers per 1,000 women (15–49) in this county."),
    popup = paste(texas_map$CNTY_NM, "County"),
    labelOptions = labelOptions(textsize = "15px", style = list("font-weight"="bold","padding"="6px"))
  ) |>

  # --- OVERLAYS (checkbox) ---
  addMarkers(
    data = providers[providers$Grantee == "FPP",],
    lat = ~Latitude, lng = ~Longitude,
    popup = ~paste0(Provider.Name, " is an FPP provider."),
    clusterOptions = markerClusterOptions(),
    group = "FPP Providers"
  ) |>
  addMarkers(
    data = providers[providers$Grantee == "HTW",],
    lat = ~Latitude, lng = ~Longitude,
    popup = ~paste0(Provider.Name, " is an HTW provider."),
    clusterOptions = markerClusterOptions(),
    group = "HTW Providers"
  ) |>

  addLayersControl(
    baseGroups    = c("Population", "Total Providers per 1,000 Women 15-49"),
    overlayGroups = c("FPP Providers", "HTW Providers"),
    position = "bottomright",
    options = layersControlOptions(collapsed = TRUE)
  ) |>

  # Legends tied to the SAME group names (so they toggle correctly)
 addLegend(
  pal = pal_pop, values = texas_map$population,
  title = "Population of women (15–49)", opacity = 1,
  group = "Population",
  className = "legend-pop"
) |>
addLegend(
  pal = pal_perk, values = texas_map$PWCT_TX_2023_total_PerK,
  title = "Total providers per 1,000 women (15–49)", opacity = 1,
  group = "Total Providers per 1,000 Women 15-49",
  className = "legend-perk"
)|>
  setMapWidgetStyle(list(background = "white")) |>
  addResetMapButton() |>

  # Start state: show Population base, hide the other base layer (important)
  hideGroup("Total Providers per 1,000 Women 15-49") |>
  # Optional: start with overlays off
  hideGroup("FPP Providers") |>
  hideGroup("HTW Providers")

m

```
:::
::::

```{ojs}
{
  const mapId = "test_map";

  const baseLabels = [
    "Population",
    "Total Providers per 1,000 Women 15-49"
  ];

  const overlayLabels = [
    "FPP Providers",
    "HTW Providers"
  ];

  // These must match the className= you set in addLegend()
  const legendClasses = {
    Population: "legend-pop",
    Providers: "legend-perk"
  };

  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function getLeafletMap() {
    const sel = `#${mapId}`;
    try {
      const w = globalThis.HTMLWidgets?.find?.(sel);
      if (w?.getMap) return w.getMap();
    } catch (e) {}
    try {
      const w2 = globalThis.HTMLWidgets?.find?.(mapId);
      if (w2?.getMap) return w2.getMap();
    } catch (e) {}
    return null;
  }

  function getLayerControlRoot() {
    const el = document.getElementById(mapId);
    return el ? el.querySelector(".leaflet-control-layers") : null;
  }

  function getTriggersForSection() {
    const mapEl = document.getElementById(mapId);
    if (!mapEl) return [];
    const section = mapEl.closest(".cr-section") || document;
    return Array.from(section.querySelectorAll(".narrative-col .trigger"));
  }

  function activeTriggerIndex() {
    const triggers = getTriggersForSection();
    if (!triggers.length) return 0;

    const vc = window.innerHeight / 2;
    let bestIdx = 0;
    let bestDist = Infinity;

    for (let i = 0; i < triggers.length; i++) {
      const r = triggers[i].getBoundingClientRect();
      const c = (r.top + r.bottom) / 2;
      const d = Math.abs(c - vc);
      if (d < bestDist) {
        bestDist = d;
        bestIdx = i;
      }
    }
    return Math.max(0, Math.min(3, bestIdx));
  }

  async function clickRadioByLabel(label) {
    const control = getLayerControlRoot();
    if (!control) return;

    const all = Array.from(control.querySelectorAll("label"));
    const target = all.find(l => (l.textContent || "").trim() === label);
    if (!target) return;

    const input = target.querySelector("input[type='radio']");
    if (input && !input.checked) input.click();
  }

  async function setOverlays({ fpp = false, htw = false }) {
    const map = getLeafletMap();
    if (!map) return;

    try { map.hideGroup(overlayLabels[0]); } catch (e) {}
    try { map.hideGroup(overlayLabels[1]); } catch (e) {}

    if (fpp) {
      try { map.showGroup(overlayLabels[0]); } catch (e) {}
    }
    if (htw) {
      try { map.showGroup(overlayLabels[1]); } catch (e) {}
    }
  }

  function showOnlyLegend(which) {
    // which = "Population" or "Providers"
    const pop = document.querySelector(`.${legendClasses.Population}`);
    const per = document.querySelector(`.${legendClasses.Providers}`);

    if (pop) pop.style.display = (which === "Population") ? "" : "none";
    if (per) per.style.display = (which === "Providers") ? "" : "none";
  }

  async function applyStep(step) {
    // 0: Population, overlays off
    // 1: Providers per 1,000, overlays off
    // 2: Providers per 1,000, FPP on
    // 3: Providers per 1,000, HTW on
    if (step === 0) {
      await clickRadioByLabel(baseLabels[0]);
      showOnlyLegend("Population");
      await setOverlays({ fpp: false, htw: false });
    } else if (step === 1) {
      await clickRadioByLabel(baseLabels[1]);
      showOnlyLegend("Providers");
      await setOverlays({ fpp: false, htw: false });
    } else if (step === 2) {
      await clickRadioByLabel(baseLabels[1]);
      showOnlyLegend("Providers");
      await setOverlays({ fpp: true, htw: false });
    } else if (step === 3) {
      await clickRadioByLabel(baseLabels[1]);
      showOnlyLegend("Providers");
      await setOverlays({ fpp: false, htw: true });
    }
  }

  async function install() {
    for (let i = 0; i < 120; i++) {
      if (getLeafletMap() && getLayerControlRoot()) break;
      await sleep(50);
    }

    const key = "__crStepSwitchInstalled";
    if (globalThis[key]) return null;
    globalThis[key] = true;

    let lastStep = -1;
    let ticking = false;

    const update = async () => {
      ticking = false;
      const step = activeTriggerIndex();
      if (step === lastStep) return;
      lastStep = step;
      await applyStep(step);
    };

    const onScroll = () => {
      if (ticking) return;
      ticking = true;
      requestAnimationFrame(update);
    };

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", onScroll, { passive: true });

    const triggers = getTriggersForSection();
    if (triggers.length) {
      const obs = new MutationObserver(onScroll);
      for (const t of triggers) obs.observe(t, { attributes: true, attributeFilter: ["class", "style"] });
    }

    await update();
    return null;
  }

  await install();
  null
}


```

### Section 4: Introduce the concept of mobile clinics

Mobile healthcare units are designed to close gaps by bringing services directly to patients and communities, especially in rural areas. Mobile clinics reduce the distance, time, and cost barriers that prevent many women from accessing care. Mobile clinics set up in trusted community spaces and adapt their routes based on need. They offer a flexible, efficient way to deliver essential women’s health services, such as birth control, cancer screenings, prenatal care, and preventive visits. For women who don’t have reliable access to transportation, mobile clinics can be a literal lifeline. When speaking to patients, they praise the convenience, as they are no longer required to travel hours from home, miss work, school, or childcare. Mobile clinics don’t just expand access; they help ensure care happens earlier, more consistently, and on patients’ terms.

### Section 5: Legislation

::: {#cr-myimage1}
![](txcapitol.gif)
:::

During the 89th Legislative Session, the Texas Women’s Healthcare Coalition and its partners secured \$20 million in new state funding to expand mobile women's health units across Texas, doubling down on a commitment to meet women where they are. This investment represents \$10 million more than the amount secured in 2023, signaling growing legislative recognition of mobile healthcare as a critical solution to access gaps. This funding is the direct result of sustained, collective advocacy and a willingness by providers to find innovative solutions to reach the counties around them.

### Section 6: On the road

A single mobile health unit can extend care across multiple counties that aren’t served by brick-and-mortar clinics. This map illustrates how mobile units move across regions with limited or no permanent healthcare infrastructures, reaching women who would otherwise face transportation barriers, or even no access at all.

### Section 7: On the ground

::: column-screen
```{=html}

<style>
/* remove default padding that creates the “white gutter” */
.column-screen { padding-left: 0 !important; padding-right: 0 !important; }
.column-screen > * { margin-left: 0 !important; margin-right: 0 !important; }

.video-wrap{
  width: 100%;
  aspect-ratio: 16 / 9;
  max-height: 100vh;
  position: relative;
  background: #0075A9E6;
}
.video-wrap iframe{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  border: 0;
}
</style>

<div class="video-wrap">
  <iframe
    src="https://www.youtube.com/embed/rwSMgGkb8sI?controls=0&modestbranding=1&rel=0&playsinline=1"
    allow="encrypted-media; picture-in-picture"
    allowfullscreen>
  </iframe>
</div>
```
:::

::: {.cr-section .quote-section layout="overlay-left"}
Learn more. @cr-mytext2

| {#cr-mytext2 .cr-text .scale-to-fill}
| "Now we're able to do a [full clinic]{#cr-t1}, just like a brick-and-mortar clinic, [just on wheels]{#cr-t2}."
| — Dr. Perales, DNP, APRN, CNS-BC
| Clinic Service Director, STFPHC
|                               
Scroll on. [@cr-mytext2]{hlz="cr-t1,cr-t2"} 
:::

### Section 8: Showing where they go

:::: {.cr-section layout="sidebar-left"}
Route animation Explaining how mobile units can go to places where there aren’t brick and mortar @cr-map2

::: {#cr-map2}
```{r map2}
#| echo: false
#| message: false
#| warning: false
library(sf)
library(dplyr)
library(leaflet)
library(rmapshaper)
library(htmlwidgets)

# --- Settings you can change ---
marker_png <- "tracer_marker.png"  # file path relative to the rendered HTML
marker_w <- 23
marker_h <- 52


routes_sf <- st_read("roads_route.gpkg", quiet = TRUE)

texas_map <- st_read("GHWMI_PCWT_2023.geojson", quiet=TRUE) |> 
  st_transform(4326) |>
  ms_simplify(keep = 0.05, keep_shapes = TRUE)

# Ensure order is integer and sorted
routes_sf <- routes_sf %>%
  mutate(order = as.integer(order)) %>%
  arrange(order)

# sf -> GeoJSON text (temp file)
geojson_file <- tempfile(fileext = ".geojson")
sf::st_write(routes_sf, geojson_file, driver = "GeoJSON", delete_dsn = TRUE, quiet = TRUE)
routes_geojson_txt <- paste(readLines(geojson_file, warn = FALSE), collapse = "\n")

# Safe embed in JS template literal
routes_geojson_txt_safe <- gsub("\\\\", "\\\\\\\\", routes_geojson_txt)
routes_geojson_txt_safe <- gsub("`", "\\\\`", routes_geojson_txt_safe)

# Safe embed for marker URL (quotes)
marker_png_safe <- gsub("\\\\", "/", marker_png)

# Build Leaflet widget
m <- leaflet(width = "68vw", height = "85vh", options = leafletOptions(zoomControl = TRUE)) %>%
  addProviderTiles("CartoDB.Positron") |>
  addPolygons(
    data = texas_map,
    group = "Population",                 # baseGroups label
    fillColor = "#FFBF3C",
    weight = 2, color = "white",
    fillOpacity = 0.80, stroke = TRUE)

# Attach JS: slow trace + gradient + moving PNG marker
js_code <- paste0(
"function(el, x) {
",
"  var map = this;

",
"  // ---- Parse GeoJSON ----
",
"  var gjText = `", routes_geojson_txt_safe, "`;
",
"  var gj;
",
"  try { gj = JSON.parse(gjText); } catch(e) {
",
"    console.error('GeoJSON parse failed:', e); return;
",
"  }
",
"  if (!gj || !gj.features || !gj.features.length) return;

",
"  // ---- Sort by order ----
",
"  var feats = gj.features.slice().sort(function(a,b){
",
"    var ao = a && a.properties ? +a.properties.order : NaN;
",
"    var bo = b && b.properties ? +b.properties.order : NaN;
",
"    if (Number.isNaN(ao) && Number.isNaN(bo)) return 0;
",
"    if (Number.isNaN(ao)) return 1;
",
"    if (Number.isNaN(bo)) return -1;
",
"    return ao - bo;
",
"  });

",
"  try {
",
"    var all = L.geoJSON(gj);
",
"    map.fitBounds(all.getBounds(), { padding: [20, 20] });
",
"  } catch(e) {}

",
"  var pointsPerPart = 200;
",
"  var partMs = 1400;
",
"  var pausePartMs = 120;
",
"  var pauseRouteMs = 220;

",
"  var start = { r: 0x00, g: 0x75, b: 0xA9, a: 0xE6/255.0 };
",
"  var end   = { r: 0x53, g: 0x28, b: 0x4F, a: 1.0 };

",
"  function lerp(a, b, t) { return a + (b-a)*t; }
",
"  function rgba(c) {
",
"    return 'rgba(' + Math.round(c.r) + ',' + Math.round(c.g) + ',' + Math.round(c.b) + ',' + c.a.toFixed(3) + ')';
",
"  }
",
"  function colorAt(t) {
",
"    t = Math.max(0, Math.min(1, t));
",
"    return rgba({
",
"      r: lerp(start.r, end.r, t),
",
"      g: lerp(start.g, end.g, t),
",
"      b: lerp(start.b, end.b, t),
",
"      a: lerp(start.a, end.a, t)
",
"    });
",
"  }

",
"  var group = L.layerGroup().addTo(map);
",
"  var markerIcon = L.icon({
",
"    iconUrl: '", marker_png_safe, "',
",
"    iconSize: [", marker_w, ", ", marker_h, "],
",
"    iconAnchor: [", round(marker_w/2), ", ", marker_h, "]
",
"  });
",
"  var tracer = null;
",
"  var tracerHeading = null;
",
"  var headingSmoothing = 0.18;
",
"  var headingMinDelta = 2.0;

",
"  function formatNumber(value, digits) {
",
"    var num = Number(value);
",
"    if (!Number.isFinite(num)) return 'n/a';
",
"    return num.toFixed(digits);
",
"  }

",
"  var totalPlannedDistance = feats.reduce(function(sum, feature) {
",
"    var props = (feature && feature.properties) ? feature.properties : {};
",
"    var dist = Number(props.distance);
",
"    return sum + (Number.isFinite(dist) ? dist : 0);
",
"  }, 0);

",
"  function buildTracerTooltip(feature, distanceDriven) {
",
"    var props = (feature && feature.properties) ? feature.properties : {};
",
"    return [
",
"      '<strong>Tracer details</strong>',
",
"      'Segment: ' + (props.order ?? 'n/a'),
",
"      'From: ' + (props.src ?? 'n/a'),
",
"      'To: ' + (props.dst ?? 'n/a'),
",
"      'Duration: ' + formatNumber(props.duration, 1) + ' min',
",
"      'Segment distance: ' + formatNumber(props.distance, 1) + ' mi',
",
"      'Total distance driven: ' + formatNumber(distanceDriven, 1) + ' mi',
",
"      'Total route distance: ' + formatNumber(totalPlannedDistance, 1) + ' mi'
",
"    ].join('<br>');
",
"  }

",
"  function bearingDeg(a, b) {
",
"    var dLng = b[0] - a[0];
",
"    var dLat = b[1] - a[1];
",
"    return Math.atan2(dLng, dLat) * (180 / Math.PI);
",
"  }
",
"  function wrapAngle180(angleDeg) {
",
"    var a = angleDeg;
",
"    while (a > 180) a -= 360;
",
"    while (a < -180) a += 360;
",
"    return a;
",
"  }
",
"  function smoothHeading(targetDeg) {
",
"    if (tracerHeading === null) { tracerHeading = targetDeg; return tracerHeading; }
",
"    var delta = wrapAngle180(targetDeg - tracerHeading);
",
"    if (Math.abs(delta) < headingMinDelta) return tracerHeading;
",
"    tracerHeading = tracerHeading + (delta * headingSmoothing);
",
"    return tracerHeading;
",
"  }
",
"  function setTracerRotation(marker, angleDeg) {
",
"    if (!marker || !marker._icon) return;
",
"    var el = marker._icon;
",
"    var base = el.style.transform || '';
",
"    base = base.replace(/\\s*rotate\\([^)]*\\)/g, '');
",
"    el.style.transformOrigin = '50% 100%';
",
"    var shownDeg = smoothHeading(angleDeg);
",
"    el.style.transform = base + ' rotate(' + shownDeg.toFixed(2) + 'deg)';
",
"  }

",
"  function densify(coords, n) {
",
"    var segLens = [], total = 0;
",
"    for (var i=0; i<coords.length-1; i++) {
",
"      var a = coords[i], b = coords[i+1];
",
"      var dx = b[0]-a[0], dy = b[1]-a[1];
",
"      var len = Math.sqrt(dx*dx + dy*dy);
",
"      segLens.push(len); total += len;
",
"    }
",
"    if (total === 0) return coords;
",
"    var out = [];
",
"    for (var k=0; k<n; k++) {
",
"      var t = (k/(n-1)) * total;
",
"      var acc = 0;
",
"      for (var s=0; s<segLens.length; s++) {
",
"        var Ls = segLens[s];
",
"        if (acc + Ls >= t || s === segLens.length-1) {
",
"          var a = coords[s], b = coords[s+1];
",
"          var local = (Ls === 0) ? 0 : (t - acc)/Ls;
",
"          out.push([ a[0] + local*(b[0]-a[0]), a[1] + local*(b[1]-a[1]) ]);
",
"          break;
",
"        }
",
"        acc += Ls;
",
"      }
",
"    }
",
"    return out;
",
"  }
",
"  function getParts(feature) {
",
"    var g = feature.geometry;
",
"    if (!g) return [];
",
"    if (g.type === 'LineString') return [g.coordinates];
",
"    if (g.type === 'MultiLineString') return g.coordinates;
",
"    return [];
",
"  }

",
"  function drawPartSlow(pts, gradientState, feature, done) {
",
"    if (!pts || pts.length < 2) { done(); return; }
",
"    if (!tracer) {
",
"      tracer = L.marker([pts[0][1], pts[0][0]], { icon: markerIcon }).addTo(map);
",
"      tracer.bindPopup(buildTracerTooltip(feature, gradientState.baseDistanceDriven), {
",
"        closeButton: true, autoClose: false, closeOnClick: false,
",
"        offset: [0, -", marker_h, "]
",
"      });
",
"      tracer.openPopup();
",
"    } else {
",
"      tracer.setLatLng([pts[0][1], pts[0][0]]);
",
"      tracer.setPopupContent(buildTracerTooltip(feature, gradientState.baseDistanceDriven));
",
"    }
",
"    tracerHeading = null;
",
"    setTracerRotation(tracer, bearingDeg(pts[0], pts[1]));
",
"    var idx = 1;
",
"    var stepMs = Math.max(10, Math.floor(partMs / pointsPerPart));
",
"    var timer = setInterval(function() {
",
"      if (idx >= pts.length) { clearInterval(timer); setTimeout(done, pausePartMs); return; }
",
"      var t = (gradientState.totalSegs <= 1) ? 1 : (gradientState.drawnSegs / (gradientState.totalSegs - 1));
",
"      var segColor = colorAt(t);
",
"      var a = pts[idx-1], b = pts[idx];
",
"      L.polyline([[a[1], a[0]], [b[1], b[0]]], { color: segColor, weight: 5, opacity: 1 }).addTo(group);
",
"      tracer.setLatLng([b[1], b[0]]);
",
"      setTracerRotation(tracer, bearingDeg(a, b));
",
"      gradientState.drawnSegs++;
",
"      var progress = (gradientState.totalSegs <= 0) ? 1 : Math.min(1, gradientState.drawnSegs / gradientState.totalSegs);
",
"      var distanceDriven = gradientState.baseDistanceDriven + (gradientState.featureDistance * progress);
",
"      tracer.setPopupContent(buildTracerTooltip(feature, distanceDriven));
",
"      idx++;
",
"    }, stepMs);
",
"  }

",
"  function drawRouteSlow(feature, baseDistanceDriven, done) {
",
"    var parts = getParts(feature);
",
"    var denseParts = parts.map(function(coords) { return densify(coords, pointsPerPart); }).filter(function(pts) { return pts && pts.length > 1; });
",
"    var totalSegs = denseParts.reduce(function(sum, pts) { return sum + (pts.length - 1); }, 0);
",
"    var props = (feature && feature.properties) ? feature.properties : {};
",
"    var featureDistance = Number(props.distance);
",
"    if (!Number.isFinite(featureDistance)) featureDistance = 0;
",
"    var gradientState = { drawnSegs: 0, totalSegs: totalSegs, baseDistanceDriven: baseDistanceDriven, featureDistance: featureDistance };
",
"    var p = 0;
",
"    function nextPart() {
",
"      if (p >= denseParts.length) { setTimeout(done, pauseRouteMs); return; }
",
"      drawPartSlow(denseParts[p], gradientState, feature, function(){ p++; nextPart(); });
",
"    }
",
"    nextPart();
",
"  }

",
"  var i = 0;
",
"  var completedDistance = 0;
",
"  function nextRoute() {
",
"    if (i >= feats.length) return;
",
"    var feature = feats[i];
",
"    drawRouteSlow(feature, completedDistance, function(){
",
"      var props = (feature && feature.properties) ? feature.properties : {};
",
"      var segDist = Number(props.distance);
",
"      if (Number.isFinite(segDist)) completedDistance += segDist;
",
"      i++;
",
"      nextRoute();
",
"    });
",
"  }
",
"  nextRoute();
",
"}
"
)

m <- onRender(m, JS(js_code))


m




```
:::
::::

### Section 9: What’s next

::: {style="text-align: center;"}
![](tracer_marker.png){width="10vw"}
:::